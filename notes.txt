Neeraj, Yogita


Day-1	(14-july-2021)
====================================================================
1. basics of java
2. oop
	inheritance, polymorphism
3. interfaces, abstract classes
4. arrays
5. 
6. java.lang
	Math
	Object
	
	String
	StringBuffer
	StringBuilder
	System
	Exception

	Thread
	Runnable
	
   java.util
	Scanner
	Date
7. exception handling
	try, catch, finally
	throw, throws



java.lang.System class:

	class variables			        object
	-------------------			---------
	public static InputStream		in
	public static PrintStream		out
	public static PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)	terminates the program then and there. int could be either a 0 or 1.
    	String getenv(String varName);
	String getevc()			to read all environment variables

    	
	


Wrapper Classes                     static method
    java.lang.Integer               parseInt(string-form-int)
    java.lang.Short
    java.lang.Byte
    java.lang.Double                parseDouble(string-form-double)
    java.lang.Boolean
    java.lang.Float
    java.lang.Character
    java.lang.Long

					parseXXX(string-form-xxx)


"100"		string-form-int

	int a = Integer.parseInt("100")	==>	100	(int)
To convert a string-form-primitive type to respective primitive type.

	double b = Double.parseDouble("12.5")	
	System.out.println(b);	// 12.5


 Boxing:
    primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   //auto-boxing

 unBoxing:
    wrapper object into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; // auto-unboxing


    String s="10";
    int x = Integer.pareInt(s);


example program
-------------------
	System.out.println(System.getenv("os"));
		
	// < jdk 1.5
	int a = 100;
	// Integer obj = Integer.valueOf(a);
	// System.out.println(obj);
		
	// >= jdk 1.5
	Integer obj2 = a;		// auto-boxing
	System.out.println(obj2);
		
	// auto-unboxing
	Double b = 123.54;
	// System.out.println(Double.valueOf(b));
	System.out.println(b);	// auto-unboxing
		
		
	// operator overloading
	Double c = b + 3;
	System.out.println(c);




developer-A
	Class  Citizen {
		
		// constructors, setters , getters
		boolean isEligibleToVote() {
		   try {
			if (getAge() <= 18)
				throw new InvalidAgeException("Not eligible to vote");
		   } catch(InvalidAgeException excep) {
			System.out.println(excep.getMessage());
		   }
			
		}		
		getAge() {

		}

	}



	InvalidAgeException extends Exception {
		public InvalidAgeException(String msg) {
			super(msg);
		}		
	}

developer-B
	VotingApp {
		psvm() {
			Citizen obj = new Citizen(....);
			if (obj.isEligibleToVote())
				sysout("your voter id is .." + voterid);

		}
	}


--------------------------------------------------------------------------------------------------

developer-A
	Class  Citizen {
		
		// constructors, setters , getters
		boolean isEligibleToVote() throws InvalidAgeException {
			if (getAge() <= 18)
				throw new InvalidAgeException("Not eligible to vote");
			
		}		
		getAge() {

		}

	}


	InvalidAgeException extends Exception {
		public InvalidAgeException(String msg) {
			super(msg);
		}		
	}

developer-B
	VotingApp {
		psvm() {
			Citizen obj = new Citizen(....);
			try {
				if (obj.isEligibleToVote())	
					sysout("your voter id is .." + voterid);
			} catch(InvalidAgeException excep) {
				System.out.println(excep.getMessage());
			}
		}
	}


two possibilities
---------------------
1) developer-A	can handle the exception 

(or)

2) developer-A  can insist to handle the exception by the consumer of the class Citizen.



Date Time API	(jdk1.8+)
--------------------------
(java.time package)
LocalDate, LocalTime, LocalDateTime
	static methods:
	---------------
	
	now()
	of()
	parse(string-form-date) : ISO Format : yyyy-mm-dd

Period	: to get the gap between two given dates.
Duration : to get the gap between two given times.

ZonedDateTime
DateTimeFormatter

Assignment:
---------------
accept login and logout times of a participant. display how long the partipant is available in the session.
eg: 5 hours 40 minutes 10 seconds.

Assigment:
--------------
StringJoiner (jdk1.8+)
write an example program using StringJoiner class.


multi threading
-------------------
thread : light weight process
asynchronous execution of different parts of same program

1) extending java.lang.Thread class
	public void run() {
		// code for the thread
	}
2) implementing java.lang.Runnable interface
	public void run() {
		// code for thread
	}

	Thread  thread = new Thread(Runnable object)

why do we need runnable again?
	
	class  A   {
	}

	class  B  extends A {
	}



	class  B  extends A, Thread {
	}   // multiple inheritance - not allowed


	// allowed
	class  B  extends A  implements Runnable {
		
	}



	


Thread life cycle:
-----------------------
1) new 
2) runnable 
3) run
4) blocked (idle)
5) dead 

life cycle methods:
--------------------
start()
run()
stop()
sleep(milli-seconds)
setDaemon(true)




thread class methods:
------------------------------

wait(), notify()
suspend(), resume() => outdated

join()


 * Daemon thread is abruptly terminated when no other threads are running.
 * It cannot run on its own.


threadName.setDaemon(true);

shared object that contains data accessed by multiple threads.
(synchronization)

1) synchronized methods
2) synchronized blocks


 				Regular Expressions
				--------------------
                                    (java.util.regex)

A regular expression defines a search pattern for strings. The short form for regular expression 
is regex. 
The search pattern can be anything from a simple character, a fixed string or a complex 
expression containing special characters describing the pattern. 

The pattern defined by the regex may match one or several times or not at all for a 
given string.

Regular expressions can be used to search, edit and manipulate text.
It is mainly for validations.


	.	any single character
	\d	single digit from 0 - 9
	\D	single character except digit
	\s	space
	\S	single character except space
	[ ]	single character of given choice or range
		eg: 	[A-Z]           any uppercase alphabet
			[abcdA-E]       a,b,c,d,A,B,C,D,E
			[0-9]           any digit
	[^ ]	single character except within the range
		eg:	[^ 1-5]         any digit other than 1,2,3,4,5

occurance indicaters:
	
	?	0 to 1 time
	*	0 to any no. of times
	+	1 to any no. of times
	{ n }	exactly 'n' times.
	{ , m}	max. 'm' times and min. is '0'.
	{n, m}	min. 'n' times and max. is 'm' times.

eg:

	mobile number	"\d{10}"
	but in java, we must say "\\d{10}"

	if we want to tell first character must not be 0, use the following pattern.
	[1-9]\\d{9}

	aadhar number	1234 1234 1234
	pattern : \\d{4}\\s\\d{4}\\s\\d{4}

	pincode		\\d{6}


	vehicle number	eg: AP31 CK 9916
				        AP31CK   1
        [1-9]

		[A-Z]{2} \d{2} [A-Z]{2} \s\d{, 3}

	aadhar id		eg: 8414 6320 8422
		\d{4} \s \d{4} \s \d{4}


java.util.regex package:
------------------------------

a) Pattern class:		to represent regular expression.
-----------------------
	methods:
	-------------
	i)	public static 	Pattern 	compile(String   regexPattern)
			it checks whether any small part of pattern is matching or not.
	
b) Matcher class:
    methods:
    i) public static   Matcher 	matcher(pattern, String)
			it checks whether the entire string should exactly match the pattern.

split method (of java.lang.String)
    i) String [] split(String)
            will extract the String based on the pattern specified.


    public class RegExDemo {
        public static void main(String [] args) {
            String mobile = "9247175823";
            String mobile2 = "92471";

            // System.out.println(mobile.matches("[1-9][0-9]{9}"));
            // System.out.println(mobile.matches("[1-9][0-9]{9}"));

            Pattern mobP = Pattern.compile("[1-9][0-9]{9}");
            Matcher m1 = mobP.matcher(mobile);
            System.out.println(m1.matches());

            String passage = "I have to port 9247212540 into a new 9247212539";
            Matcher m2 = mobP.matcher(passage);
            System.out.println(m2.find());
        }
    }





`//Duration d = Duration.between(LocalTime.NOON,LocalTime.MAX);  
 System.out.println(d.get(ChronoUnit.HOURS) + d.get(ChronoUnit.MINUTES) + d.get(ChronoUnit.SECONDS));   




Day-2	(15-july-2021)
============================================================================================================

Generics

	add - int a, int b ->  sum of a+b
	add - double a, double b -> sum of a+b
	add - String a, String b -> concatenation of a,b



T  add (T  a, T b) {
	return a+b;
}

T stands for any datatype


add(10,5)	->	T is assumed as int
add(1.2, 2.3)	->	T is assumed as double
add("Srinivas", "D") -> T is assumed as String




Data Structures
	It is the way of storing and organizing data.

	1. linear
		one-beside-other
		arrays, , stack, queue
	2. non-linear
		linked list, graph, tree


	static data structures : arrays
	dynamic data structures : except arrays

Collections Framework   (Collections API) - ( java.util )
------------------------------------------
API  stands for Application Programming Interface
API contain built-in classes, interfaces, packages.
To store group of objects.

Linear:  
	Objects are stored in a linear fashion
	Objects can be numbered which we call as index
	Linear data structure supports index based operations.

	Linear data structure supports sequential access 
	Also Supports random access.

Non linear:
    Not in linear fashion so we do not have index here and 
    thus we cannot access them randomly.



Collections are divided into 3 parts:
	
	a) Declaration Part: 
	Here we have interfaces 

	b) Implementation part: 
		Set<-- HashSet,LinkedHashSet.
		SortedSet<---------Treeset
		List<------ArrayList,LinkedList


	Collection interface methods:
       	{ size(), contains(object), add(object), remove(object) }

List:
---------
    List allow duplicate elements.

	ArrayList-->interally uses an expandable array to store the elements.
	If there are too many insertions and deletions LinkedList is recommended.
	If there are too many retrievals arrayList will perform better.
    Vector is a legacy class.



    ArrayList class
        DEFAULT_CAPACITY = 10
        elementData is an Object[] where the data of array list is stored.
        everytime the grow() method is called, the array is extended by 50%.
        newCapacity = oldCapacity + (oldCapacity >> 1);

        methods:
        --------
        add()
        isEmpty()
        size()
        remove(index)
        set(index, value)
        get(index)
        clear()
        equals()
        indexOf(value)
        lastIndexOf()
        toArray() : convert array list into an array.
        sort()

    LinkedList:
    -----------
        it is in the form of linked list.
        it can be used when you are having frequent updations.

        1) addFirst()
        2) addLast()
        3) removeFirst()
        4) removeLast()

    Vector:
    -------
        default capacity = 10
        when a new elements is added when the existing cells are filled, the capacity is
        DOUBLED.


    Iterator:
        which allows to iterate through a collection.

        iterator()
        hasNext()
        next()

   
Set:
-------
    Set will not allow duplicate elements where as list will allow the same.

	HashSet --> Order is undefined.
	LinkedHashSet--> Insertion Order
	TreeSet-> maintains sorted order

        null is not allowed in TreeSet. we get NullPointerException.

    index based retrieval is not possible.
    


Queue:
    FIFO    (first in, first out)
    insertions will happen at begining.
    deletions also happend at beginning.
PriorityQueue

ArrayDequeue



Map:
----
	  

    Maps are used to store key-value pair data. (It is also called as Dictionary)
    In map, keys are not sorted in order
    In sorted map, keys are in sorted order 
    key cannot be duplicated.
    value can be duplicated.
    index based retrieval is not possible.
    value can be retrieved if a key is given.

    put(key,value)
    get(key)
    set(key,value)
    remove(key)
    size()
    contains(key)
    keySet() : return all keys
    values() : return all values
    containsKey()
    containsValue()
    entrySet() : entry means combination of key and value
    

    implementation classes:
	HashTable   (legacy class)
        HashMap
        LinkedHashMap
        TreeMap



java.util.Collections class:
----------------------------
1) sort()
2) binarySearch(list, key)
3) fill(list, object)

    java.lang.Comparable interface:
    --------------------------------
    it contain only one abstract method
    
    public int compareTo(T object)

    The class should know how do you want to sort.  (intenally)
    The class must implement java.lang.Comparable interface.





	







assignment:
    	1) one program on vector
	2) What is the difference between Vector and ArrayList?
	3) What is the difference between iterator and enhanced for?
	4) atleast one program on queue
	5) one program on hashtable
	6) difference between hashtable and hashmap

	
Develop a multi-layered application to manage employees of an organization.

EmployeeManagementSystem
-------------------------------
Employee
	empNumber, empName, dateJoined, basicSalary, hra, da, net
	hra = 80% of basicSalary
	da = 60% of basicSalary
	net = basicSalary + hra + da
	
	include validations.

Application should be able to
	i) add a new employee
	ii) remove an existing employee when empNumber is given
	iii) list all the employees in the alphabetical order of empName
	iv) list all the employees in the order of recent to past.
	v) list all the employees as per their salary increasing order
	vi) update an existing employee (empNumber should not be modified)
	
	
	











		










 Regular Expressions
						           --------------------
                                    (java.util.regex)

A regular expression defines a search pattern for strings. The short form for regular expression 
is regex. 
The search pattern can be anything from a simple character, a fixed string or a complex 
expression containing special characters describing the pattern. 
The pattern defined by the regex may match one or several times or not at all for a 
given string.
Regular expressions can be used to search, edit and manipulate text.
It is mainly for validations.


	.	any single character
	\d	single digit from 0 - 9
	\D	single character except digit
	\s	space
	\S	single character except space
	[ ]	single character of given choice or range
		eg: 	[A-Z]           any uppercase alphabet
			    [abcdA-E]       a,b,c,d,A,B,C,D,E
			    [0-9]           any digit
	[^ ]	single character except within the range
		eg:	[^ 1-5]         any digit other than 1,2,3,4,5
	\w 	(word character) matches any single alphabet, digit or underscore (same as [a-zA-Z0-9_] ).

occurance indicaters:
	
	?	0 to 1 time 
	*	0 to any no. of times
	+	1 to any no. of times
	{ n }	exactly 'n' times.
	{ , m}	max. 'm' times and min. is '0'.
	{n, m}	min. 'n' times and max. is 'm' times.

eg:

	mobile number	"\d{10}"
	but in java, we must say "\\d{10}"

	but first digit cannot be 0. so , it must be given as ...	"[1-9]\\d{9}"

	vehicle number	eg: AP31 CK 9916
				        AP31CK   1
        [1-9]

		[A-Z]{2} \d{2} [A-Z]{2} \s\d{, 3}

	aadhar id		eg: 8414 6320 8422
		\d{4} \s \d{4} \s \d{4}


java.util.regex package:
------------------------------

a) Pattern class:		to represent regular expression.
-----------------------
	methods:
	-------------
	i)	public static 	Pattern 	compile(String   regexPattern)
			it checks whether any small part of pattern is matching or not.
	
b) Matcher class:
    methods:
    i) public static   Matcher 	matches(pattern, String)
			it checks whether the entire string should exactly match the pattern.

split method (of java.lang.String)
    i) String [] split(String)
            will extract the String based on the pattern specified.


    public class RegExDemo {
        public static void main(String [] args) {
            String mobile = "9247175823";
            String mobile2 = "92471";

            // System.out.println(mobile.matches("[1-9][0-9]{9}"));
            // System.out.println(mobile.matches("[1-9][0-9]{9}"));

            Pattern mobP = Pattern.compile("[1-9][0-9]{9}");
            Matcher m1 = mobP.matcher(mobile);
            System.out.println(m1.matches());

            String passage = "I have to port 9247212540 into a new 9247212539";
            Matcher m2 = mobP.matcher(passage);
            System.out.println(m2.find());
        }
    }




===============================================================================================
Day-2   (15-july-2021)

Collections


java.lang.Comparable interface:
	it provide the ability to compare objects for a class during sorting operation.


	override compareTo()

	int compareTo(Object o) {
		// relevant code
	}

	return value is ZERO, if two objects are equal
	return value is +VE, if invoking is object is big
	eturn value is -VE, if paramter object is big

java.util.Comparator interface
	
	it provide the ability to compare objects for a class during sorting operation.
	we need not modify the source class (eg: Book)
	we must create a sub class of Comparator interface.
	and override compare() and provide respective logic.

assignments:
---------------------------------------
1) vector example program
2) difference between arraylist and vector	
3) diff between enhanced for loop and iterator
4) queue example program
5) hashtable example program
6) diff between hashtable and hashmap
7) implement CategoryWise Sorted or BookList

====================================================================================================================
Day-3   [16-july-2021]

class Student {
	rollno
	name

	// constructors, s, g, t
}

Student s1 = new Student(1, "abcd");
Student s2 = new Student(1, "abcd");

System.out.println(s1 == s2);	// false
System.out.println(s1.equals(s2)); // true


There is contract between equals() and hashCode() ?
	when two objects are true as per equals() method, then the hashcodes must be true.



					Multi-Layered Architecture
					--------------------------


UI  <-->  Service  <--> DAO Layer (persistence layer)  <-->   DB / IOStream / Collection....
	  
SoC   (Seperation of Concern)
Program-to-interfaces
Loosely Coupled

Design Patterns
DAO (Data Access Object) design pattern 


Exception handling must be done only in UI Layer. (try-catch)
Remaining layers simply throw the exception to the previous layer  (Exception Propogation)

CRUD (Create-Read-Update-Delete) operations

Service -> Business Logic (validations, computations) + calling the respective DAO implementation methods
Validations can be done using regular expressions.

=========================================================================================================================
Day-4   [17-july-2021]

						IOStream (java.io)
						------------------
To store data permanantly.
stream: flow of data 

1) character stream (or) text stream
	Reader
		BufferedReader
		FileReader
			read() : read one character at a time. it return an int.
	Writer
		BufferWriter
		PrintWriter
		FileWriter
	to store textual information.

2) byte stream (or) binary stream
	InputStream
		FileInputStream
		ObjectInputstream
	OutputStream
		FileOutputStream
		ObjectOutputStream

	to store images, audio, video, objects.

When ever you open a file, it occupy a special memory, known as "resource".
The file must be closed once the job is done. otherwise it leads to "resource leak".


JDK1.7  :  try-with-resources
	it will take care of closing the resource.
	
	try (open_your_resource_here) {

	} catch(Exception  e) {

	}

	resource you mention in the try block, must be an AutoClosable.
	AutoClosable is an interface.

assignment
---------------------
1) create a text file "courses.txt", store few course names.
   write a java program to read the contents of the above file and with the same content create a new file "new-courses.txt"
   (File Copy Program)

java.nio	
-----------------------
Path
Paths
Files

2) do the FileCopy program using NIO
3) delete a file using NIO

	

java.io.Serializable interface
	which is used to mark a class, so that objects of that particular class can be serialized.
	it has no methods to override.
	it is also known as "Marker Interface".


Serialization : storing object in a file
DeSerialization : reading object in a file



Functional interface:
-----------------------
It is an interface contain only one abstract method.


                                    Lambda Expressions (JDK 1.8)
                                    ----------------------------

it allows functonality to be passed as an argument to the function.
it is a replacement of Anonymous class that implements a functional interface.
(eg: Comparable, Runnable)

components of lambda expressions:
1) a comma-separated list of formal parameters enclosed in paranthesis
2) we can omit paranthesis if it is a single parameter
3) the arrow token ( -> ) is known as lambda operator
4) a body which consists of a single expression, or statement block.


Interface IArithmetic {
    int add(int a, int b);
    int diff(int a, int b);
}


class ArithmeticImpl implements Arithmetic {
    @Override 
    public int add(int a, int b) {
        return a+b;
    }
    @Override
    public int diff(int a, int b) {
        return a-b;
    }
}

public class Test {
    public static void main(String[] args) {
        ArithmeticImpl obj = new ArithmeticImpl();
        System.out.println(obj.add(10, 5));
        System.out.println(obj.diff(10, 6));
    }
}


using Anonymous class:
----------------------
Interface IArithmetic {
    int add(int a, int b);
    int diff(int a, int b);
}

public class Test {
    public static void main(String[] args) {
        IArithmetic obj = new IArithmeticImpl(new Arithmetic() {
            @Override 
            public int add(int a, int b) {
                return a+b;
            }
            @Override
            public int diff(int a, int b) {
                return a-b;
            }
        })
        System.out.println(obj.add(10, 5));
        System.out.println(obj.diff(10, 6));
    }
}


 			Built-in functional interfaces
                        -----------------------------

Comparable, Comparator, Runnable
marked with @FunctionInterface annotation


java.util.function package
--------------------------
interface           abstract method
-----------------------------------------------------------------
Consumer<T>         void    accept(T)
Supplier<T>         T       get()
Predicate<T>        boolean test(T)
Function<T,R>       R       apply(T)
UnaryOperator<T>    T       apply(T)
BinaryOperator<T>   T       apply(T,T)


                                    Streams
                                    -------
                                (java.util.Stream)

Stream is a flow of data from a data source.
where data source can be an array or any other collection.
streams once consumed we cannot use it again.


1) java.util.stream.Stream.of(array);
    create a stream taken array as a data source.
2) java.util.Collection::stream()
    create a stream taken any collection like list,set as a data source.

    Stream s1 = Stream.of(array);
    Stream s2 = list.stream();
    Stream s3 = set.stream();


stream() and parallelStream() ?
    stream() will operate on one core.
    parallelStream() will operate on multiple cores. (hardware related)


java.util.stream.Stream methods (operators):
operators    accepts         returns             does                                       type
-------------------------------------------------------------------------------------------------------
1) forEach      a consumer      void                executes the consumer on each element   terminal operation
2) collect      a Collector     a Collection        gather all elments in the stream into   terminal operation
                                                    collection.
3) reduce       BinaryOperator  java.util.Optional  execute the binary operator on each     terminal operation


                                                   pair of element in the stream.

                what is a Collector?
                    Collectors.toList()
                    Collectors.toSet()
                    Collectors.toMap(KeyMaper, ValueMapper)

        List<Employee> emps = Arrays.asList(
            new Employee(...),
            new Employee(...),
            new Employee(...),
            ...
        )


	for(Employee employee : emps) {
		System.out.println(employee);
	}

	(or)


        emps.stream.forEach(e -> System.out.println(e));

        println is also a consumer. so, we can simplify ... using method reference
        emps.stream.forEach(System.out::println);
        here we are not calling println, rather we are passing println function to System.out
        and on every element println is executed.

        create a map with empid as key and emp object as value:
        -------------------------------------------------------
        Map<Integer, Employee> empMap = 
            emps.stream().collect(Collectors.toMap(e -> e.getEmpId(), e -> e));
        System.out.println(empMap);

        create a set from array list:
        -----------------------------
        Set<Employee> empSet = emps.stream().collect(Collectors.toSet());
        System.out.println(empSet);


        Stream s = Stream.of(new int[] {1,2,3,4,5,6});
        Optional<Integer> sum = s.reduce( (x,y) -> x+y);
        System.out.println(sum.isPresent() ? sum : null);

        Optional<Employee> costlyEmployee = emps.stream().reduce( 
            (e1, e2) -> e1.getSalary() > e2.getSalary() ? e1 : e2);
        System.out.println(costlyEmployee.isPresent() ? costlyEmployee.get() : null);
        
        why Optional?
            it helps to avoid NULL POINTER EXCEPTION.

        Optional<Employee> senior = emps.stream().reduce( 
            (e1, e2) -> e1.getHireDate().isBefore(e2.getHireDate()) ? e1 : e2);
        System.out.println(senior.isPresent() ? senior.get() : null);


    filter(Predicate)                   :   intermediate operation
    map(Functional transformer)         :   intermediate operation
    sorted(BinaryOperator)              :   intermediate operation   
    flatMap(Functional transformer)     :   intermediate operation


StreamAPIDemo.java          (vam-repo)       
    books.stream().forEach(System.out::println);

    books.stream().forEach( (b) -> {
        b.setPrice(b.getPrice()*2);
    });
    books.stream().forEach(System.out::println);


int [] a = {1,2,3,4,5};
Stream s = Stream.of(a);
BinaryOperator<Integer> bo = (a,b) -> a+b;
s.reduce(o);        // return Optional<Integer> = 15
    ((((1+2)+3)+4)+5) = 15

to see a latest published book :
    Optional<Book> latestPublishedBook = books.stream().reduce( (b1,b2) -> b1.getDateOfPublished().isAfter(b2.getDateOfPublished()) ? b1 : b2));
    System.out.println(latestPublishedBook.get());  

to see list of books whose price is less than 4000 :
    books.stream().filter( b -> b.getPrice() <= 4000).forEach(System.out::println);

to convert list into set :
    Set<book> bookSet = books.stream().collect(Collectors.toSet());
    System.out.println(bookSet);


    List<Book> lessPricedBooks = books.stream()
                                    .filter( b -> b.getPrice() <= 4000)
                                    .collect(Collectors.toList());
        System.out.println(lessPricedBooks)
map :
    int [] a = {1,2,3,4,5};
    Stream.of(a).map( n->n*n ).forEach(System.out::println);        // 1,4,9,16,25
    Stream.of(a).map( n->"Hello"+n).forEach(System.out.println);
    
    List<String> bookNames = books.stream().map( b -> b.getName()).collect(Collectors.toList());
    System.out.println(bookNames);
    (or)
    List<String> bookNames = books.stream().map(Book::getName).collect(Collectors.toList());
    System.out.println(bookNames);

sorted :
    using comparable :
    books.stream().sorted().forEach(System.out::println);   
    
    using comparator :
    books.stream().sorted( (b1,b2) -> b1.getDateOfPublished().compareTo(b2.getDateOfPublished()))
            .forEach(System.out::println);

flatMap :
    if we have an array of arrays (stream of streams), and we want to flaten that into a 
    single array (or stream), flatMap is used.

    add a property is called authors.
    private String[] authors;
    add another constructor that takes authors along with other properties.
    generate getters and setters for authors.
    regenerate hashcode, equals and toString methods.

    in the main program, create book objects using the newly added constructor and provide
    authors of each book along with other details.

    books.stream().map(Book::getAuthors)
        .flatMap(b -> Stream.of(b.getAuthors()))
        .distinct()
        .forEach(System.out::println);




List<Employee>  employeeList = new ArrayList<>();
employeeList.add(new Employee(....));
...


for(Employee employee : employeeList) {
    if (employee.getSalary() >= 5000) {
        System.out.println(employee);
    }
}

(or)

Stream<Employee>  filteredStream = employeeList.stream()
            .filter(emp -> emp.getSalary() >= 500);
filteredStream.forEach(emp -> System.out.println(emp));


methods:
--------
boolean                         allMatch(Predicate predicate)   
boolean                         anyMatch(Predicate predicate)
long                            count()
Stream<T>                       distinct()
static<T> Stream<T>             empty()
Stream<T>                       filter(Predicate predicate)
Optional<T>                     findAny()
Optional<T>                     findFirst()
void                            forEach(Consumer<T> action)
Stream<T>                       limit(size)
Stream<T>                       skip(size)
Stream                          map(Function )
Option<T>                       max(Comparator )
Option<T>                       min(Comparator )
Stream<T>                       sorted()
Stream<T>                       sorted(Comparator )
Object[]                        toArray()



	






